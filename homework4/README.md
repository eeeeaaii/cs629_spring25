# Homework 4: Ray Tracer

You will complete the implementation of a raytracer,
as discussed in class and in your book. Your raytracer will render one scene as a still image, using `Frame`, `Renderer`, and `Color` classes, like in homework 3. The code for the renderer will be in the `renderer` folder, as before.

The files that you will need to complete are:
```
raytracer.cpp
sphere.cpp
triangle.cpp
```


At startup, your raytracer will read in a configuration file that contains all the information about what is in the scene. The code for parsing that configuration file will be provided to you, so you can focus on the raytracing part. The code for doing this is in the `configfile` folder.

You also have a vector class you can use with the standard vector operations (in the `vect` folder).

You will also be provided a set of 12 example files and output PNGs showing what the raytracer should display when run with that configuration file. These are the same files that will be used for grading your assignment.

Note that only examples 1-9 are required. The rest (10, 11, and 12) are optional/extra credit (see below).

As previous assignments, please do not alter the contents of any folder except the source folder. I will put your source files in the src folder and compile it on my machine.

Your raytracer needs to support the following entity types:

* spheres
* triangles
* point lights
* directional lights (one per scene)

And the following lighting calculations:
* ambient
* diffuse
* specular


Some notes:
* The focal length of your raytracer will be passed in via the config file. You should use this information when computing the viewing ray.
* specular reflections will be white, and all light sources will emit white light.
* The specular reflectance computation given in the notes should be finally multiplied by the "glossiness" value in the scene data file (a value between 0 and 1). This basically indicates how reflective the surface is.
* The amount of diffuse reflection is just controlled by the color you are using for diffuse/ambient lighting (use a darker color for objects that have few diffuse reflections).
* directional lights are specified with a vector that tells you the direction the light is shining.

## Config file

Even though the config files are provided for you, I recommend you take a look at them.

### Parsed Data

The data that is parsed by the config file will be returned back to you from the parse method in the format defined in `configfile/scenedata.h`

## Drawing API

The drawing API is exactly the same as your line drawing assignment.


## Debugger

I've given you a debugger class. To use the debugger, anywhere in your code that you want to debug something, type:

```
DEBUGGER.set_value(some_number)
```

You may have to also import the debugger, i.e.:

```
extern Debugger DEBUGGER;
```

The debugger is meant to be used in your code that is drawing a different thing for every pixel on the screen. When you call `set_value`, it will set the value for that specific pixel, so you will get a "debug image" that has values from black to white, showing what the debug value was for each point in the image.

If you set values that are less than 0, or greater than 1, the debugger will scale them so the largest values are white and the smallest values are black.

If you don't set any values, the debugger will not appear and you'll just see the real image that your raytracer is drawing.

A scenario where you might use the debugger might be like this:
1. You're trying to write code to shade a pixel, but it's not having the effect you want.
2. You insert calls to `set_value`, and instead of seeing your output image, you see an image generated by the debugger, with the value you passed to `set_value` in every pixel.
3. By looking at the greyscale image, you are able to figure out what's going wrong, and you fix your code.
4. You remove the call to `set_value`, and now your picture is rendering again.


## Optional Extra Credit

Your raytracer is not required to perfect (mirror) reflections, or shadows. If you want to implement those too, you can, for extra credit. The example file for mirror reflections (example 12) is rendered with 5 bounces.
